%{
    #include <iostream>
    #include "hw3_output.hpp"
    #include "ScopeHandler.hpp"
    #include "Node.hpp"
    #include <string>
    #include <memory>
    #define YYSTYPE Node*;
    using namespace std;
    using namespace output;
    int yylex();
    void yyerror(const char*);
	extern int yylineno;
    std::string ret_type;
    std::string func_name;
    std::vector<std::string> argNames;
    std::vector<std::string> argTypes;
    int while_count = 0;
    ScopeHandler scopeHandler();
%}

%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN

%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SC
%nonassoc LPAREN
%nonassoc LBRACE
%nonassoc RBRACE
%nonassoc NUM
%nonassoc STRING
%nonassoc ID
%nonassoc COMMA
%nonassoc IF


%left ASSIGN
%left OR
%left AND
%left EQUAL
%left RELOP
%left PLUS_MINUS
%left MUL_DIV
%right NOT 
%nonassoc RPAREN
%nonassoc ELSE


%%
M_New_Scope:   /*epsilon*/ {scopeHandler.newScope();}
;

M_End_Scope:   /*epsilon*/ {scopeHandler.endScope();}
;

M_While:        /*epsilon*/ {while_count++;}
;

M_Add_Function: /*epsilon*/ { 
                                if(!scopeHandler.addFunction(func_name, ret_type, argNames, argTypes)){
                                    output::errorDef(yylineno, func_name);
                                    exit(0);   
                                }
                            }
;



Program:        Funcs {}
;

Funcs:          /*epsilon*/{}
                | FuncDecl Funcs {}
;

FuncDecl:       RetType ID {func_name = $2->name;} LPAREN Formals RPAREN M_Add_Function LBRACE M_New_Scope Statements RBRACE /* release marker*/    {
                                                                                                                                                        ret_type = "";
                                                                                                                                                        func_name = "";
                                                                                                                                                        argNames.clear();
                                                                                                                                                        argTypes.clear();
                                                                                                                                                        scopeHandler.endScope();
                                                                                                                                                    }
;

RetType:        Type{
                        ret_type = $1->type;
                    }
                | VOID  {
                            ret_type = "VOID";
                        }
;

Formals:        /*epsilon*/{}
                | FormalsList {}
;

FormalsList:    FormalDecl {}
                | FormalDecl COMMA FormalsList {}
;

FormalDecl:     Type ID {
                            argTypes.insert(argTypes.begin(), $1->type);
                            argNames.insert(argNames.begin(), $2->name);
                        }
;

Statements:     Statement {}
                |Statements Statement {}
                
;

Statement:      LBRACE M_New_Scope Statements RBRACE{
                                                        scopeHandler.endScope();
                                                    }
                | Type ID SC{
                                if (!scopeHandler.addSymbol($2->name,$1->type);){
                                    output::errorDef(yylineno, $2->name);
                                    exit(0); 
                                }     
                            }
                | Type ID ASSIGN Exp SC {
                                            if(($1->type != $4->type) and (($4->type != "BYTE") 
                                                or ($1->type != "INT"))){
                                                output::errorMismatch(yylineno);
                                                exit(0);
                                            }
                                            if (!scopeHandler.addSymbol($2->name,$1->type);){
                                                output::errorDef(yylineno, $2->name);
                                                exit(0); 
                                            }
                                            
                                        }
                | ID ASSIGN Exp SC  {
                                        TableEntry* entry = scopeHandler.findSymbol($1->name);
                                        if (!entry){
                                            output::errorUndef(yylineno, $1->name);
                                            exit(0); 
                                        }
                                        if((entry->type != $3.type) and
                                            ((entry->type != "INT") or ($3.type != "BYTE"))){
                                                output::errorMismatch(yylineno);
                                                exit(0); 
                                        }
                                    }
                | Call SC {}
                | RETURN SC {
                                if(ret_type != "VOID"){
                                    output::errorMismatch(yylineno);
                                    exit(0);
                                }
                                    
                            }
                | RETURN Exp SC {
                                if(ret_type != $2->type){
                                    output::errorMismatch(yylineno);
                                    exit(0);
                                }
                                }
                | IF LPAREN Exp RPAREN M_New_Scope Statement { scopeHandler.endScope(); }
                | IF LPAREN Exp RPAREN M_New_Scope Statement M_End_Scope ELSE M_New_Scope Statement {
                                                                                                        scopeHandler.endScope();
                                                                                                    }
                | WHILE M_While LPAREN Exp RPAREN M_New_Scope Statement{
                                                                            while_count--;
                                                                            scopeHandler.endScope();
                                                                        }
                | BREAK SC {
                             if(!while_count){
                                output::errorUnexpectedBreak(yylineno);
                                exit(0);
                             }
                            }
                | CONTINUE SC   {
                                 if (!while_count){
                                    output::errorUnexpectedContinue(yylineno);
                                    exit(0);
                                 }
                                }
;

Call:       ID LPAREN ExpList RPAREN{
                                        TableEntry* entry =scopeHandler.findSymbol($1->name);
                                        if (!entry){
                                            output::errorUndefFunc(yylineno, const $1->name);
                                            exit(0);
                                        }
                                        if(entry->type.find("->") == -1){
                                            output::errorUndefFunc(yylineno, const $1->name);
                                            exit(0);
                                        }
                                        std::vector<std::string> params = getFuncParams(entry);
                                        if($3->expressions.size() != params.size()){
                                            output::errorPrototypeMismatch(yylineno, entry->name, params);
                                            exit(0);
                                        } 
                                        int i = 0;
                                        for(auto& exp : $3->expressions){
                                            if((exp->type != params[i]) and ((exp->type != "BYTE") 
                                                or (params[i] != "INT"))){
                                                output::errorPrototypeMismatch(yylineno, entry->name, params);
                                                exit(0);
                                            }
                                            ++i;
                                        }
                                        $$->type == getFuncReturn(entry);                                    
                                    }
            | ID LPAREN RPAREN  {
                                    TableEntry* entry =scopeHandler.findSymbol($1->name);
                                    if (!entry){
                                            output::errorUndefFunc(yylineno, const $1->name);
                                            exit(0);
                                    }
                                    if(entry->type.find("->") == -1){
                                        output::errorUndefFunc(yylineno, const $1->name);
                                        exit(0);
                                    }
                                    vector<string> params = getFuncParams(entry);
                                    if (params.size() != 0){
                                        output::errorPrototypeMismatch(yylineno, entry->name, params);
                                        exit(0);
                                    }
                                    $$->type == getFuncReturn(entry);  
                                }
;   

ExpList:    Exp {
                    ExpList* expList = new ExpList(std::vector<Exp>());
                    expList->expressions.push_back(Exp($1->type));
                    $$ = expList; 
                }
            | Exp COMMA ExpList {
                                    ExpList* expList = new ExpList($3->expressions); //potential bug
                                    expList->expressions.insert(expList.begin(), Exp($1->type));  
                                    $$ = expList; 
                                }
;

Type:     INT   {
                    $$ = new Type("INT");
                }
        | BYTE  {
                    $$ = new Type("BYTE");
                }
        | BOOL  {
                    $$ = new Type("BOOL");
                }
;


Exp:    LPAREN Exp RPAREN   { 
                                $$ = new Exp($2->type);
                            }
        | Exp IF LPAREN Exp RPAREN ELSE Exp {
                                                if($4->type == "BOOL" and 
                                                ($1->type == $7->type or ($1->type == "BYTE" and $7->type == "INT"))){
                                                    $$ = new Exp($7->type);
                                                }
                                                else if($4->type == "BOOL" and 
                                                ($1->type == "INT" and $7->type == "BYTE")){
                                                    $$ = new Exp($1->type);
                                                }
                                                else{
                                                    output::errorMismatch(yylineno); 
                                                    exit(0);
                                                }
                                            }
        | Exp PLUS_MINUS Exp{
                                if ($1->type == "INT" ){
                                    if($2->type == "INT" or $2->type == "BYTE")
                                        $$ = new Exp("INT");
                                    else{
                                        output::errorMismatch(yylineno); 
                                        exit(0);
                                    };
                                }
                                if else ($1->type == "BYTE"){
                                    if($2->type == "INT")
                                        $$ = new Exp("INT");
                                    if else($2->type == "BYTE")
                                        $$ = new Exp("BYTE");
                                    else{
                                        output::errorMismatch(yylineno); 
                                        exit(0);
                                    }
                                }
                                else{
                                    output::errorMismatch(yylineno); 
                                    exit(0);
                                }
                            }
        | Exp MUL_DIV Exp   {
                                if ($1->type == "INT" ){
                                    if($2->type == "INT" or $2->type == "BYTE")
                                        $$ = new Exp("INT");
                                    else{
                                        output::errorMismatch(yylineno); 
                                        exit(0);
                                    };
                                }
                                if else ($1->type == "BYTE"){
                                    if($2->type == "INT")
                                        $$ = new Exp("INT");
                                    if else($2->type == "BYTE")
                                        $$ = new Exp("BYTE");
                                    else{
                                        output::errorMismatch(yylineno); 
                                        exit(0);
                                    }
                                }
                                else{
                                    output::errorMismatch(yylineno); 
                                    exit(0);
                                }                            
                            }
        | ID{  
                TableEntry* entry =scopeHandler.findSymbol($1->name);
                if(entry)
                    if(entry->type.find("->") == -1)
                        $$ = new Exp(entry->type);
                    else{
                        void errorUndef(yylineno, $1->name);
                        exit(0);                        
                    }
                else{
                    void errorUndef(yylineno, $1->name);
                    exit(0);
                }
            }
        | Call { 
                    $$ = new Exp($1->type);
               }
        | NUM   { 
                    $$ = new Exp("INT");
                }
        | NUM B {
                    if ($1->value <= 255) 
                        $$ = new Exp("BYTE");
                    else{
                        output::errorByteTooLarge(yylineno,std::to_string($1->value));
                        exit(0);
                    }
                }
        | STRING{ 
                    $$ = new Exp("STRING"); 
                }
        | TRUE  { 
                    $$ = new Exp("BOOL"); 
                }
        | FALSE { 
                    $$ = new Exp("BOOL"); 
                }
        | NOT Exp   { 
                        if($2->type == "BOOL")
                            $$ = new Exp("BOOL");
                            
                        else{
                            output::errorMismatch(yylineno); 
                            exit(0);
                            }
                    }
        | Exp AND Exp   {
                            if($1->type == "BOOL" and $3->type == "BOOL")
                                $$ = new Exp("BOOL");
                            else{
                                output::errorMismatch(yylineno); 
                                exit(0);
                            }     
                        }
        | Exp OR Exp{ 
                        if($1->type == "BOOL" and $3->type == "BOOL")
                            $$ = new Exp("BOOL");
                        else{
                            output::errorMismatch(yylineno); 
                            exit(0);
                        }
                        
                    }      
        | Exp RELOP Exp { 
                            if(($1->type == "INT" or $1->type == "BYTE") 
                                and ($3->type == "INT" or $3->type == "BYTE"))
                                        $$ = new Exp("BOOL");
                            else{
                                output::errorMismatch(yylineno);
                                exit(0);
                            }
                        }
        | Exp EQUAL Exp { 
                            if(($1->type == "INT" or $1->type == "BYTE") 
                                and ($3->type == "INT" or $3->type == "BYTE"))
                                    $$ = new Exp("BOOL");
                            else{
                                output::errorMismatch(yylineno);
                                exit(0);
                            }
                        }
        | LPAREN Type RPAREN Exp{  
                                    if ($2->type == "INT" and ($4->type == "INT" or $4->type == "BYTE"))
                                        $$ = new Exp("INT");
                                    else if ($2->type == "BYTE" and ($4->type == "INT" or $4->type == "BYTE"))
                                        $$ = new Exp("BYTE");
                                    else{
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    }  
                                }
;

%%

void yyerror(const char*) 
{ 
    errorSyn(yylineno);
    exit(0); 
}
int main() {
    return yyparse();
}
