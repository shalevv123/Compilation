%{
    #include <iostream>
    #include "hw3_output.hpp"
    #include "ScopeHandler.hpp"
    #include "Node.hpp"
    #include "bp.hpp"
    #include <string>
    #include <memory>
    //#define YYDEBUG 1
    using namespace std;
    using namespace output;
    int yylex();
    void yyerror(const char*);
	extern int yylineno;
    std::string ret_type;
    std::string func_name;
    std::vector<std::string> argNames;
    std::vector<std::string> argTypes;
    int while_count = 0;
    std::vector<std::vector<std::pair<int,BranchLabelIndex>>> breakList;
    std::vector<std::vector<std::pair<int,BranchLabelIndex>>> continueList;
    bool returned = false;
    std::string returnLabel;
    ScopeHandler scopeHandler;
%}

%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN

%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SC
%nonassoc LPAREN
%nonassoc LBRACE
%nonassoc RBRACE
%nonassoc NUM
%nonassoc STRING
%nonassoc ID
%nonassoc COMMA
%nonassoc IF


%left ASSIGN
%right TERNARY
%left OR
%left AND
%left EQUAL
%left RELOP
%left PLUS_MINUS
%left MUL_DIV
%right NOT 
%nonassoc RPAREN
%nonassoc ELSE


%%
Program:        Funcs   {
                            if(yychar == YYEOF){
                                        TableEntry* mainSym = scopeHandler.findSymbol("main");
                                        if(!mainSym){
                                            output::errorMainMissing();
                                            exit(0);
                                        }
                                        if ((mainSym->type).find("->") == -1){
                                            output::errorMainMissing();
                                            exit(0);
                                        }
                                        if(getFuncReturn(mainSym) != "VOID"){
                                            output::errorMainMissing();
                                            exit(0);
                                        }
                                        if(getFuncParams(mainSym).size() != 0){
                                            output::errorMainMissing();
                                            exit(0);
                                        }
                                        scopeHandler.endScope();
                                        CodeBuffer::instance().printGlobalBuffer();
                                        CodeBuffer::instance().printCodeBuffer();


                            }
                        }
;

Funcs:          /*epsilon*/{}
                | FuncDecl Funcs {}
;

FuncDecl:       RetType ID {func_name = static_cast<Id*>($2)->name;} LPAREN Formals RPAREN M_Add_Function /*a new scope is created*/
                LBRACE Statements RBRACE /* release marker*/    {
                                                                    scopeHandler.endScope();
                                                                    ret_type = "";
                                                                    func_name = "";
                                                                    argNames.clear();
                                                                    argTypes.clear();
                                                                    if(!returned){
                                                                        returnLabel = CodeBuffer::instance().genLabel();
                                                                        std::string str = "ret void";
                                                                        CodeBuffer::instance().emit(str);
                                                                        str = "}";
                                                                        CodeBuffer::instance().emit(str);
                                                                    }
                                                                    CodeBuffer::instance().bpatch(static_cast<Statement*>($9)->nextList, returnLabel);
                                                                    returned = false;
                                                                    returnLabel = "";

                                                                    delete $1;
                                                                    delete $9;
                                                                }
;

RetType:        Type{
                        ret_type = static_cast<Type*>($1)->type;


                        delete $1;
                    }
                | VOID  {
                            ret_type = "VOID";
                        }
;

Formals:        /*epsilon*/{}
                | FormalsList {}
;

FormalsList:    FormalDecl {}
                | FormalDecl COMMA FormalsList {}
;

FormalDecl:     Type ID {
                            argTypes.push_back(static_cast<Type*>($1)->type);
                            argNames.push_back(static_cast<Id*>($2)->name);


                            delete $1;
                        }
;
M:              /*epsilon*/ { 
                                $$ = new BoolExp();
                                static_cast<BoolExp*>($$)->midLabel = CodeBuffer::instance().genLabel(); 
                            }
;
N:              /*epsilon*/ {
                                $$ = new Statement();
                                std::string str = "br label @";
                                int label = CodeBuffer::instance().emit(str);
                                static_cast<Statement*>($$)->nextList.emplace_back(label, FIRST);
                            }
;
M_New_Scope:   /*epsilon*/ {scopeHandler.newScope();}
;

M_End_Scope:   /*epsilon*/ {scopeHandler.endScope();}
;

M_While:        /*epsilon*/ {
                                while_count++;
                                breakList.emplace_back();
                                continueList.emplace_back();
                            }
;

M_Add_Function: /*epsilon*/ { 
                                std::shared_ptr<std::string> bad_name = scopeHandler.addFunction(func_name, ret_type, argNames, argTypes);
                                if(bad_name){
                                    output::errorDef(yylineno, *bad_name);
                                    exit(0);   
                                }
                            }
;

Statements:     Statement   {
                                $$ = new Statement();
                                static_cast<Statement*>($$)->nextList = static_cast<Statement*>($1)->nextList; 

                                delete $1;
                            }
                |Statements M Statement {
                                            $$ = new Statement();
                                            static_cast<Statement*>($$)->nextList = static_cast<Statement*>($3)->nextList; 
                                            CodeBuffer::instance().bpatch(static_cast<Statement*>($1)->nextList, 
                                                                          static_cast<BoolExp*>($2)->midLabel);
                                            delete $1;
                                            delete $2;
                                            delete $3;
                                        }

                
;

Statement:      LBRACE M_New_Scope Statements RBRACE{
                                                        $$ = new Statement();
                                                        static_cast<Statement*>($$)->nextList = static_cast<Statement*>($3)->nextList;
                                                        scopeHandler.endScope();

                                                        delete $3;
                                                    }
                | Type ID SC{
                                if (!scopeHandler.addSymbol(static_cast<Id*>($2)->name, static_cast<Type*>($1)->type, 
                                    static_cast<Type*>($1)->type == "BOOL" ? "false" : std::to_string(0))){
                                    output::errorDef(yylineno, static_cast<Id*>($2)->name);
                                    exit(0); 
                                }
                                else{
                                    TableEntry* entry = scopeHandler.findSymbol(static_cast<Id*>($2)->name);
                                    entry->emit_store("%base"); //TODO: change base pointer
                                    $$ = new Statement();
                                }
                                delete $1;     
                            }
                | Type ID ASSIGN Exp SC {
                                            if((static_cast<Type*>($1)->type != static_cast<Exp*>($4)->type) and ((static_cast<Exp*>($4)->type != "BYTE") 
                                                or (static_cast<Type*>($1)->type != "INT"))){
                                                output::errorMismatch(yylineno);
                                                exit(0);
                                            }
                                            if (!scopeHandler.addSymbol(static_cast<Id*>($2)->name,static_cast<Type*>($1)->type,
                                                 static_cast<Type*>($4)->type == "BOOL" ? static_cast<BoolExp*>($4)->evaluate() :  static_cast<Exp*>($4)->var)){
                                                output::errorDef(yylineno, static_cast<Id*>($2)->name);
                                                exit(0); 
                                            }
                                            else{
                                                TableEntry* entry = scopeHandler.findSymbol(static_cast<Id*>($2)->name);
                                                entry->emit_store("%base"); //TODO: change base pointer
                                                $$ = new Statement();
                                            }
                                            delete $1;
                                            delete $4;
                                        }
                | ID ASSIGN Exp SC  {
                                        TableEntry* entry = scopeHandler.findSymbol(static_cast<Id*>($1)->name);
                                        if (!entry){
                                            output::errorUndef(yylineno, static_cast<Id*>($1)->name);
                                            exit(0); 
                                        }
                                        if(entry->type.find("->") != -1){
                                            output::errorUndef(yylineno, static_cast<Id*>($1)->name);
                                            exit(0);
                                        }
                                        if((entry->type != static_cast<Exp*>($3)->type) and
                                            ((entry->type != "INT") or (static_cast<Exp*>($3)->type != "BYTE"))){
                                                output::errorMismatch(yylineno);
                                                exit(0); 
                                        }

                                        entry->var = static_cast<Type*>($3)->type == "BOOL" ? static_cast<BoolExp*>($3)->evaluate() :  static_cast<Exp*>($3)->var;
                                        entry->emit_store("%base"); //TODO: change base pointer
                                        $$ = new Statement();
                                        delete $3;
                                    }
                | Call SC {

                            delete $1;
                          }
                | RETURN SC {
                                if(ret_type != "VOID"){
                                    output::errorMismatch(yylineno);
                                    exit(0);
                                }
                            }
                | RETURN Exp SC {
                                    if(ret_type == "VOID"){
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    }
                                    if(ret_type != static_cast<Exp*>($2)->type and ((static_cast<Exp*>($2)->type != "BYTE") 
                                        or (ret_type != "INT"))){
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    }
                                    returnLabel = CodeBuffer::instance().genLabel();
                                    // TODO: add return line
                                    returned = true;

                                    delete $2;
                                }
                | IF LPAREN M_Bool_Exp RPAREN M M_New_Scope Statement   { 
                                                                            scopeHandler.endScope();
                                                                            CodeBuffer::instance().bpatch(static_cast<BoolExp*>($3)->trueList,
                                                                                                          static_cast<BoolExp*>($5)->midLabel);
                                                                            $$ = new Statement();
                                                                            static_cast<Statement*>($$)->nextList = CodeBuffer::merge(static_cast<BoolExp*>($3)->falseList,
                                                                                                                                      static_cast<Statement*>($7)->nextList);
                                                                            delete $3;
                                                                            delete $5;
                                                                            delete $7;
                                                                        }
                | IF LPAREN M_Bool_Exp RPAREN M M_New_Scope Statement N ELSE M_End_Scope M_New_Scope M Statement{
                                                                                                                    scopeHandler.endScope();
                                                                                                                    CodeBuffer::instance().bpatch(static_cast<BoolExp*>($3)->trueList,
                                                                                                                                                  static_cast<BoolExp*>($5)->midLabel);
                                                                                                                    CodeBuffer::instance().bpatch(static_cast<BoolExp*>($3)->falseList,
                                                                                                                                                  static_cast<BoolExp*>($12)->midLabel);

                                                                                                                    $$ = new Statement();
                                                                                                                    static_cast<Statement*>($$)->nextList = CodeBuffer::merge(static_cast<Statement*>($7)->nextList, CodeBuffer::merge(static_cast<Statement*>($8)->nextList,
                                                                                                                                                                              static_cast<Statement*>($13)->nextList));                              

                                                                                                                    delete $3;
                                                                                                                    delete $5;
                                                                                                                    delete $7;
                                                                                                                    delete $8;
                                                                                                                    delete $12;
                                                                                                                    delete $13;
                                                                                                                }
                | WHILE M_While M LPAREN M_Bool_Exp RPAREN M_New_Scope M Statement{

                                                                                        CodeBuffer::instance().bpatch(static_cast<BoolExp*>($5)->trueList,
                                                                                                                      static_cast<BoolExp*>($8)->midLabel);
                                                                                        CodeBuffer::instance().bpatch(static_cast<Statement*>($9)->nextList,
                                                                                                                      static_cast<BoolExp*>($3)->midLabel);
                                                                                        $$ = new Statement();
                                                                                        static_cast<Statement*>($$)->nextList = CodeBuffer::merge(static_cast<BoolExp*>($5)->falseList, breakList.back());
                                                                                        std::string str = "br label %" + static_cast<BoolExp*>($3)->midLabel;
                                                                                        CodeBuffer::instance().emit(str);

                                                                                        CodeBuffer::instance().bpatch(continueList.back(),
                                                                                                                      static_cast<BoolExp*>($3)->midLabel);
                                                                                        while_count--;
                                                                                        breakList.pop_back();
                                                                                        continueList.pop_back();
                                                                                        scopeHandler.endScope();

                                                                                        delete $3;
                                                                                        delete $5;
                                                                                        delete $8;
                                                                                        delete $9;
                                                                                    }
                | BREAK SC  {
                                if(!while_count){
                                    output::errorUnexpectedBreak(yylineno);
                                    exit(0);
                                }
                                $$ = new Statement();
                                std::string str = "br label @";
                                int bp = CodeBuffer::instance().emit(str);
                                breakList.back().emplace_back(bp, FIRST);
                            }
                | CONTINUE SC   {
                                    if (!while_count){
                                        output::errorUnexpectedContinue(yylineno);
                                        exit(0);
                                    }
                                    $$ = new Statement();
                                    std::string str = "br label @";
                                    int bp = CodeBuffer::instance().emit(str);
                                    continueList.back().emplace_back(bp, FIRST);

                                }
;

Call:       ID LPAREN ExpList RPAREN{
                                        TableEntry* entry =scopeHandler.findSymbol(static_cast<Id*>($1)->name);
                                        if (!entry){
                                            output::errorUndefFunc(yylineno,  static_cast<Id*>($1)->name);
                                            exit(0);
                                        }
                                        if(entry->type.find("->") == -1){
                                            output::errorUndefFunc(yylineno, static_cast<Id*>($1)->name);
                                            exit(0);
                                        }
                                        std::vector<std::string> params = getFuncParams(entry);
                                        if(static_cast<ExpList*>($3)->expressions.size() != params.size()){
                                            output::errorPrototypeMismatch(yylineno, entry->name, params);
                                            exit(0);
                                        } 
                                        int i = 0;
                                        for(auto& exp : static_cast<ExpList*>($3)->expressions){
                                            if((exp.type != params[i]) and ((exp.type != "BYTE") 
                                                or (params[i] != "INT"))){
                                                output::errorPrototypeMismatch(yylineno, entry->name, params);
                                                exit(0);
                                            }
                                            ++i;
                                        }
                                        $$ = new Call(getFuncReturn(entry));

                                        delete $3;                                    
                                    }
            | ID LPAREN RPAREN  {
                                    TableEntry* entry =scopeHandler.findSymbol(static_cast<Id*>($1)->name);
                                    if (!entry){
                                            output::errorUndefFunc(yylineno,  static_cast<Id*>($1)->name);
                                            exit(0);
                                    }
                                    if(entry->type.find("->") == -1){
                                        output::errorUndefFunc(yylineno,  static_cast<Id*>($1)->name);
                                        exit(0);
                                    }
                                    vector<string> params = getFuncParams(entry);
                                    if (params.size() != 0){
                                        output::errorPrototypeMismatch(yylineno, entry->name, params);
                                        exit(0);
                                    }
                                    $$ = new Call(getFuncReturn(entry));   
                                }
;   

ExpList:    Exp {
                    ExpList* expList = new ExpList(std::vector<Exp>());
                    expList->expressions.push_back(Exp(static_cast<Exp*>($1)->type));
                    $$ = expList;

                    delete $1; 
                }
            | Exp COMMA ExpList {
                                    ExpList* expList = new ExpList(static_cast<ExpList*>($3)->expressions); //potential bug
                                    expList->expressions.insert(expList->expressions.begin(), Exp(static_cast<Exp*>($1)->type));  
                                    $$ = expList;

                                    delete $1;
                                    delete $3; 
                                }
;

Type:     INT   {
                    $$ = new Type("INT");
                }
        | BYTE  {
                    $$ = new Type("BYTE");
                }
        | BOOL  {
                    $$ = new Type("BOOL");
                }
;

M_Bool_Exp: Exp {
                    if(static_cast<Exp*>($1)->type != "BOOL"){
                        output::errorMismatch(yylineno);
                        exit(0);
                    }
                    $$ = new BoolExp(static_cast<Exp*>($1)->var);

                    delete $1;
                }
;

Exp:    LPAREN Exp RPAREN   { 
                                $$ = new Exp(static_cast<Exp*>($2)->type, static_cast<Exp*>($2)->var);

                                delete $2;
                            }
        | Exp IF LPAREN M_Bool_Exp RPAREN ELSE Exp %prec TERNARY
                                            {
                                                if(static_cast<Exp*>($1)->type == static_cast<Exp*>($7)->type or (static_cast<Exp*>($1)->type == "BYTE" and static_cast<Exp*>($7)->type == "INT")){
                                                    $$ = new Exp(static_cast<Exp*>($7)->type);
                                                }
                                                else if(static_cast<Exp*>($1)->type == "INT" and static_cast<Exp*>($7)->type == "BYTE"){
                                                    $$ = new Exp(static_cast<Exp*>($1)->type);
                                                }
                                                else{
                                                    output::errorMismatch(yylineno);
                                                    exit(0);
                                                }

                                                delete $1;
                                                delete $7;
                                            }
        | Exp PLUS_MINUS Exp{
                                if (static_cast<Exp*>($1)->type == "INT" ){
                                    if(static_cast<Exp*>($3)->type == "INT" or static_cast<Exp*>($3)->type == "BYTE")
                                    {    
                                        $$ = new Exp("INT", CodeBuffer::instance().freshVar());
                                        static_cast<Exp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<PlusMinus*>($2)->op, static_cast<Exp*>($3));
                                    }
                                    else{
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    }
                                }
                                else if (static_cast<Exp*>($1)->type == "BYTE"){
                                    if(static_cast<Exp*>($3)->type == "INT")
                                    {    
                                        $$ = new Exp("INT", CodeBuffer::instance().freshVar());
                                        static_cast<Exp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<PlusMinus*>($2)->op, static_cast<Exp*>($3));
                                    }
                                    else if(static_cast<Exp*>($3)->type == "BYTE")
                                    {    
                                        $$ = new Exp("BYTE", CodeBuffer::instance().freshVar());
                                        static_cast<Exp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<PlusMinus*>($2)->op, static_cast<Exp*>($3));
                                    }                                    
                                    else{
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    }
                                }
                                else{
                                    output::errorMismatch(yylineno);
                                    exit(0);
                                }


                                delete $1;
                                delete $3;
                            }
        | Exp MUL_DIV Exp   {
                                if (static_cast<Exp*>($1)->type == "INT" ){
                                    if(static_cast<Exp*>($3)->type == "INT" or static_cast<Exp*>($3)->type == "BYTE")
                                    {    
                                        $$ = new Exp("INT", CodeBuffer::instance().freshVar());
                                        static_cast<Exp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<MulDiv*>($2)->op, static_cast<Exp*>($3));
                                    }
                                    else{
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    };
                                }
                                else if (static_cast<Exp*>($1)->type == "BYTE"){
                                    if(static_cast<Exp*>($3)->type == "INT")
                                    {    
                                        $$ = new Exp("INT", CodeBuffer::instance().freshVar());
                                        static_cast<Exp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<MulDiv*>($2)->op, static_cast<Exp*>($3));
                                    }
                                    else if(static_cast<Exp*>($3)->type == "BYTE")
                                    {    
                                        $$ = new Exp("BYTE", CodeBuffer::instance().freshVar());
                                        static_cast<Exp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<MulDiv*>($2)->op, static_cast<Exp*>($3));
                                    }
                                    else{
                                        output::errorMismatch(yylineno); 
                                        exit(0);
                                    }
                                }
                                else{
                                    output::errorMismatch(yylineno); 
                                    exit(0);
                                }
                                
                                delete $1;
                                delete $3;                            
                            }
        | ID{  
                TableEntry* entry =scopeHandler.findSymbol(static_cast<Id*>($1)->name);
                if(entry){
                    std::string var = entry->emit_load("%base"); //TODO: change base pointer
                    if(entry->type.find("->") == -1){
                        if(entry->type == "BOOL"){
                            $$ = new BoolExp(var);
                            static_cast<BoolExp*>($$)->emit();
                        }
                        else
                            $$ = new Exp(entry->type, var);
                    }
                    else{
                        output::errorUndef(yylineno, static_cast<Id*>($1)->name);
                        exit(0);                        
                    }
                }
                else{
                    output::errorUndef(yylineno, static_cast<Id*>($1)->name);
                    exit(0);
                }
            }
        | Call { 
                    $$ = new Exp(static_cast<Call*>($1)->type);

                    delete $1;
               }
        | NUM   { 
                    $$ = new Exp("INT", std::to_string((static_cast<Num*>($1))->value));
                }
        | NUM B {
                    if (static_cast<Num*>($1)->value <= 255) 
                        $$ = new Exp("BYTE", std::to_string((static_cast<Num*>($1))->value));
                    else{
                        output::errorByteTooLarge(yylineno,std::to_string(static_cast<Num*>($1)->value));
                        exit(0);
                    }
                }
        | STRING{ 
                    $$ = new StringExp(static_cast<String*>($1)->value, CodeBuffer::instance().freshVar()); 
                    static_cast<StringExp*>($$)->emitGlobalString();
                }   

        | TRUE  { 
                    $$ = new BoolExp("true");
                    static_cast<BoolExp*>($$)->emit(); 
                }
        | FALSE { 
                    $$ = new BoolExp("false");
                    static_cast<BoolExp*>($$)->emit();  
                }
        | NOT Exp   { 
                        if(static_cast<Exp*>($2)->type == "BOOL")
                            {    
                                $$ = new BoolExp(static_cast<Exp*>($2)->var);
                                static_cast<BoolExp*>($$)->notOp(static_cast<Exp*>($2));
                            }
                            
                        else{
                            output::errorMismatch(yylineno);
                            exit(0);
                        }
                        

                        delete $2; 
                    }
        | Exp AND M Exp   {
                            if(static_cast<Exp*>($1)->type == "BOOL" and static_cast<Exp*>($4)->type == "BOOL")
                            {    
                                $$ = static_cast<BoolExp*>($3);
                                static_cast<BoolExp*>($$)->emitOp(static_cast<Exp*>($1), "and", static_cast<Exp*>($4));
                            }
                            else{
                                output::errorMismatch(yylineno);
                                exit(0);
                            }

                            delete $1;
                            delete $4;     
                        }
        | Exp OR M Exp{ 
                        if(static_cast<Exp*>($1)->type == "BOOL" and static_cast<Exp*>($4)->type == "BOOL")
                            {    
                                $$ = static_cast<BoolExp*>($3);
                                static_cast<BoolExp*>($$)->emitOp(static_cast<Exp*>($1), "or", static_cast<Exp*>($4));
                            }
                        else{
                            output::errorMismatch(yylineno);
                            exit(0);
                        }
                        
                        delete $1;
                        delete $4;
                    }      
        | Exp RELOP Exp { 
                            if((static_cast<Exp*>($1)->type == "INT" or static_cast<Exp*>($1)->type == "BYTE") 
                                and (static_cast<Exp*>($3)->type == "INT" or static_cast<Exp*>($3)->type == "BYTE"))
                                    {    
                                        $$ = new BoolExp(CodeBuffer::instance().freshVar());
                                        static_cast<BoolExp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<Relop*>($2)->op, static_cast<Exp*>($3));
                                    }
                            else{
                                output::errorMismatch(yylineno);
                                exit(0);
                            }

                            delete $1;
                            delete $3;
                        }
        | Exp EQUAL Exp { 
                            if((static_cast<Exp*>($1)->type == "INT" or static_cast<Exp*>($1)->type == "BYTE") 
                                and (static_cast<Exp*>($3)->type == "INT" or static_cast<Exp*>($3)->type == "BYTE"))
                                    {    
                                        $$ = new BoolExp(CodeBuffer::instance().freshVar());
                                        static_cast<BoolExp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<Equal*>($2)->op, static_cast<Exp*>($3));
                                    }
                            else{
                                output::errorMismatch(yylineno);
                                exit(0);
                            }

                            delete $1;
                            delete $3;
                        }
        | LPAREN Type RPAREN Exp{  
                                    if (static_cast<Type*>($2)->type == "INT" and (static_cast<Exp*>($4)->type == "INT" or static_cast<Exp*>($4)->type == "BYTE"))
                                        $$ = new Exp("INT",static_cast<Exp*>($4)->var);
                                    else if (static_cast<Type*>($2)->type == "BYTE" and (static_cast<Exp*>($4)->type == "INT" or static_cast<Exp*>($4)->type == "BYTE"))
                                        {
                                        $$ = new Exp("BYTE", static_cast<Exp*>($4)->var);
                                        if(static_cast<Exp*>($4)->type != "BYTE")
                                            static_cast<Exp*>($$)->emitOp(nullptr, "", nullptr);
                                        }
                                    else{
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    }

                                    delete $2;
                                    delete $4;  
                                }
;

%%

void yyerror(const char*) 
{ 
    errorSyn(yylineno);
    exit(0); 
}
void prologue(){
    CodeBuffer::instance().emitGlobal("declare i32 @printf(i8*, ...)");
    CodeBuffer::instance().emitGlobal("declare void @exit(i32)");
    CodeBuffer::instance().emitGlobal("@.int_specifier = constant [4 x i8] c\"%d\\0A\\00\"");
    CodeBuffer::instance().emitGlobal("@.str_specifier = constant [4 x i8] c\"%s\\0A\\00\"");
    CodeBuffer::instance().emitGlobal("@.div_error = internal constant [23 x i8] c\"Error division by zero\\00\"");
    CodeBuffer::instance().emit("define void @printi(i32) {");
    CodeBuffer::instance().emit("\t%spec_ptr = getelementptr [4 x i8], [4 x i8]* @.int_specifier, i32 0, i32 0");
    CodeBuffer::instance().emit("\tcall i32 (i8*, ...) @printf(i8* %spec_ptr, i32 %0)");
    CodeBuffer::instance().emit("\tret void");
    CodeBuffer::instance().emit("}");
    CodeBuffer::instance().emit("define void @print(i8*) {");
    CodeBuffer::instance().emit("\t%spec_ptr = getelementptr [4 x i8], [4 x i8]* @.str_specifier, i32 0, i32 0");
    CodeBuffer::instance().emit("\tcall i32 (i8*, ...) @printf(i8* %spec_ptr, i8* %0)");
    CodeBuffer::instance().emit("\tret void");
    CodeBuffer::instance().emit("}");
}

int main() {

    //yydebug = 1;
    prologue();
    return yyparse();
}
