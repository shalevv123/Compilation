%{
    #include <iostream>
    #include "hw3_output.hpp"
    #include "ScopeHandler.hpp"
    #include "Node.hpp"
    #include "bp.hpp"
    #include <string>
    #include <memory>
    #include <algorithm> 
    //#define YYDEBUG 1
    using namespace std;
    using namespace output;
    int yylex();
    void yyerror(const char*);
	extern int yylineno;
    std::string ret_type = "";
    std::string func_name = "";
    std::vector<std::string> argNames;
    std::vector<std::string> argTypes;
    int while_count = 0;
    std::vector<std::vector<std::pair<int,BranchLabelIndex>>> breakList;
    std::vector<std::vector<std::pair<int,BranchLabelIndex>>> continueList;
    ScopeHandler scopeHandler;
    bool returned = false; // FIX return check
    std::string base = "";
    std::vector<std::pair<int,BranchLabelIndex>> baseList;
%}
%nonassoc LOW_PRIORITY
%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN

%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SC
%nonassoc LPAREN
%nonassoc LBRACE
%nonassoc RBRACE
%nonassoc NUM
%nonassoc STRING
%nonassoc ID
%nonassoc COMMA
%nonassoc IF


%left ASSIGN
%right TERNARY
%left OR
%left AND
%left EQUAL
%left RELOP
%left PLUS_MINUS
%left MUL_DIV
%right NOT 
%nonassoc RPAREN
%nonassoc ELSE


%%
Program:        Funcs   {
                            if(yychar == YYEOF){
                                        TableEntry* mainSym = scopeHandler.findSymbol("main");
                                        if(!mainSym){
                                            output::errorMainMissing();
                                            exit(0);
                                        }
                                        if ((mainSym->type).find("->") == -1){
                                            output::errorMainMissing();
                                            exit(0);
                                        }
                                        if(getFuncReturn(mainSym) != "VOID"){
                                            output::errorMainMissing();
                                            exit(0);
                                        }
                                        if(getFuncParams(mainSym).size() != 0){
                                            output::errorMainMissing();
                                            exit(0);
                                        }
                                        scopeHandler.endScope();
                                        CodeBuffer::instance().printGlobalBuffer();
                                        CodeBuffer::instance().printCodeBuffer();


                            }
                        }
;

Funcs:          /*epsilon*/{}
                | FuncDecl Funcs {}
;

FuncDecl:       RetType ID {func_name = static_cast<Id*>($2)->name;} LPAREN Formals RPAREN M_Add_Function /*a new scope is created*/
                LBRACE Statements RBRACE /* release marker*/    {
                                                                    std::string str;
                                                                    if(!returned){ 
                                                                        if (ret_type == "VOID") 
                                                                            str = "ret void";
                                                                        else if (ret_type == "INT" or ret_type == "BYTE")
                                                                            str = "ret i32 0";
                                                                        else if (ret_type == "BOOL")
                                                                            str = "ret i1 0";
                                                                        CodeBuffer::instance().emit(str);
                                                                    }
                                                                    str = "}";
                                                                    CodeBuffer::instance().emit(str);

                                                                    CodeBuffer::instance().bpatchSize(baseList, std::to_string(std::max(0, scopeHandler.localVars())));
                                                                    returned = false;
                                                                    scopeHandler.endScope();
                                                                    ret_type = "";
                                                                    func_name = "";
                                                                    base = "";
                                                                    baseList.clear();
                                                                    argNames.clear();
                                                                    argTypes.clear();

                                                                    delete $2;
                                                                    delete $9;
                                                                }
;

RetType:        Type{
                        ret_type = static_cast<Type*>($1)->type;


                        delete $1;
                    }
                | VOID  {
                            ret_type = "VOID";
                        }
;

Formals:        /*epsilon*/{}
                | FormalsList {}
;

FormalsList:    FormalDecl {}
                | FormalDecl COMMA FormalsList {}
;

FormalDecl:     Type ID {
                            argTypes.push_back(static_cast<Type*>($1)->type);
                            argNames.push_back(static_cast<Id*>($2)->name);


                            delete $1;
                            delete $2;
                        }
;
M:  /*epsilon*/ %prec LOW_PRIORITY{ 
                                $$ = new BoolExp();
                                static_cast<BoolExp*>($$)->midLabel = CodeBuffer::instance().genLabel(); 
                            }
;
N:     /*epsilon*/ %prec LOW_PRIORITY{  
                                $$ = new Statement();
                                std::string str = "br label @";
                                int label = CodeBuffer::instance().emit(str);
                                static_cast<Statement*>($$)->nextList.emplace_back(label, FIRST);
                            }
;
M_New_Scope:   /*epsilon*/ {scopeHandler.newScope();}
;

M_End_Scope:   /*epsilon*/ {scopeHandler.endScope();}
;

M_While:        /*epsilon*/ {
                                while_count++;
                                breakList.emplace_back();
                                continueList.emplace_back();
                            }
;

M_Add_Function: /*epsilon*/ {
                                 
                                std::string str = "";
                                str += "define ";
                                if (ret_type == "BOOL")
                                    str+= "i1 ";
                                else if(ret_type == "VOID")
                                    str+= "void ";
                                else
                                    str+= "i32 ";
                                str += "@" + func_name + "(";
                                std::vector<std::string> varList;
                                if(!argTypes.empty()){
                                for (auto& type : argTypes){
                                    std::string var = CodeBuffer::instance().freshVar();
                                    varList.push_back(var);
                                    str += type == "BOOL" ? "i1 " + var + ", " : "i32 " + var + ", ";
                                }
                                str.pop_back();
                                str.pop_back();
                                }
                                str += ") {";
                                CodeBuffer::instance().emit(str);
                                std::shared_ptr<std::string> bad_name = scopeHandler.addFunction(func_name, ret_type, argNames, argTypes, varList);
                                if(bad_name){
                                    output::errorDef(yylineno, *bad_name);
                                    exit(0);   
                                }



                                std::string var = CodeBuffer::instance().freshVar();
                                str = var + " = alloca [@ x i32]";
                                int bp = CodeBuffer::instance().emit(str);
                                base = var;
                                baseList.emplace_back(bp, FIRST);
                            }
;

Statements:     Statement{

                                $$ = new Statement();
                                returned = static_cast<Statement*>($1)->isRet;
                                    
                                if (static_cast<Statement*>($1)->isControl){
                                    std::string label = CodeBuffer::instance().genLabel(); 
                                    CodeBuffer::instance().bpatch(static_cast<Statement*>($1)->nextList, label);
                                }
                                delete $1;
                            }
                |Statements Statement  {
                                            $$ = new Statement();
                                            returned = static_cast<Statement*>($2)->isRet;

                                            if (static_cast<Statement*>($2)->isControl){
                                                std::string label = CodeBuffer::instance().genLabel(); 
                                                CodeBuffer::instance().bpatch(static_cast<Statement*>($2)->nextList, label);
                                            }                                            
                                
                                            delete $1;
                                            delete $2;
                                        }

                
;

Statement:      LBRACE M_New_Scope Statements RBRACE{
                                                        $$ = new Statement();
                                                        static_cast<Statement*>($$)->nextList = static_cast<Statement*>($3)->nextList;
                                                        scopeHandler.endScope();

                                                        delete $3;
                                                    }
                | Type ID SC{
                                if (!scopeHandler.addSymbol(static_cast<Id*>($2)->name, static_cast<Type*>($1)->type, 
                                    static_cast<Type*>($1)->type == "BOOL" ? "false" : std::to_string(0))){
                                    output::errorDef(yylineno, static_cast<Id*>($2)->name);
                                    exit(0); 
                                }
                                else{
                                    TableEntry* entry = scopeHandler.findSymbol(static_cast<Id*>($2)->name);
                                    entry->emit_store(base, baseList); //TODO: change base pointer
                                    $$ = new Statement();
                                }
                                delete $1;  
                                delete $2;   
                            }
                | Type ID ASSIGN Exp SC {
                                            if((static_cast<Type*>($1)->type != static_cast<Exp*>($4)->type) and ((static_cast<Exp*>($4)->type != "BYTE") 
                                                or (static_cast<Type*>($1)->type != "INT"))){
                                                output::errorMismatch(yylineno);
                                                exit(0);
                                            }
                                            if (!scopeHandler.addSymbol(static_cast<Id*>($2)->name,static_cast<Type*>($1)->type,
                                                 (static_cast<Exp*>($4)->type == "BOOL") ? static_cast<BoolExp*>($4)->evaluate() :  static_cast<Exp*>($4)->var)){
                                                output::errorDef(yylineno, static_cast<Id*>($2)->name);
                                                exit(0); 
                                            }
                                            else{
                                                TableEntry* entry = scopeHandler.findSymbol(static_cast<Id*>($2)->name);
                                                entry->emit_store(base, baseList); //TODO: change base pointer
                                                $$ = new Statement();
                                            }

                                            static_cast<Exp*>($4)->selfBPatch();

                                            delete $1;
                                            delete $2;
                                            delete $4;
                                        }
                | ID ASSIGN Exp SC  {
                                        TableEntry* entry = scopeHandler.findSymbol(static_cast<Id*>($1)->name);
                                        if (!entry){
                                            output::errorUndef(yylineno, static_cast<Id*>($1)->name);
                                            exit(0); 
                                        }
                                        if(entry->type.find("->") != -1){
                                            output::errorUndef(yylineno, static_cast<Id*>($1)->name);
                                            exit(0);
                                        }
                                        if((entry->type != static_cast<Exp*>($3)->type) and
                                            ((entry->type != "INT") or (static_cast<Exp*>($3)->type != "BYTE"))){
                                                output::errorMismatch(yylineno);
                                                exit(0); 
                                        }

                                        entry->var = (static_cast<Exp*>($3)->type == "BOOL") ? static_cast<BoolExp*>($3)->evaluate() :  static_cast<Exp*>($3)->var;
                                        entry->emit_store(base, baseList); //TODO: change base pointer
                                        $$ = new Statement();
                                        
                                        static_cast<Exp*>($3)->selfBPatch();
                                        delete $1;
                                        delete $3;
                                    }
                | Call SC {
                            static_cast<CallExp*>($1)->selfBPatch();
                            $$ = new Statement();
                            delete $1;
                          }
                | RETURN SC {
                                if(ret_type != "VOID"){
                                    output::errorMismatch(yylineno);
                                    exit(0);
                                }
                                $$ = new Statement();
                                static_cast<Statement*>($$)->isRet = true;

                                std::string str = "ret void";
                                CodeBuffer::instance().emit(str);
                                
                            }
                | RETURN Exp SC {
                                    if(ret_type == "VOID"){
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    }
                                    if(ret_type != static_cast<Exp*>($2)->type and ((static_cast<Exp*>($2)->type != "BYTE") 
                                        or (ret_type != "INT"))){
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    }
                                    $$ = new Statement();
                                    static_cast<Statement*>($$)->isRet = true;
                                    if(static_cast<Exp*>($2)->type == "BOOL"){
                                        std::string var = static_cast<BoolExp*>($2)->evaluate();
                                        std::string str = "ret i1 " + var;
                                        CodeBuffer::instance().emit(str);
                                    }
                                    else{
                                        std::string var = static_cast<Exp*>($2)->var;
                                        std::string str = "ret i32 " + var;
                                        CodeBuffer::instance().emit(str);
                                    }

                                    static_cast<Exp*>($2)->selfBPatch();
                                    delete $2;
                                }
                | IF LPAREN M_Bool_Exp RPAREN M M_New_Scope Statement N{ 
                                                                            scopeHandler.endScope();
                                                                            CodeBuffer::instance().bpatch(static_cast<BoolExp*>($3)->trueList,
                                                                                                          static_cast<BoolExp*>($5)->midLabel);
                                                                            $$ = new Statement();
                                                                            static_cast<Statement*>($$)->isControl = true;

                                                                        
                                                                            static_cast<Statement*>($$)->nextList = CodeBuffer::merge(static_cast<BoolExp*>($3)->falseList,
                                                                                                                    CodeBuffer::merge(static_cast<Statement*>($7)->nextList,
                                                                                                                                      static_cast<Statement*>($8)->nextList));
                                                                            
                                                                            static_cast<Exp*>($3)->selfBPatch();
                                                                            delete $3;
                                                                            delete $5;
                                                                            delete $7;
                                                                            delete $8;
                                                                        }
                | IF LPAREN M_Bool_Exp RPAREN M M_New_Scope Statement ELSE N M_End_Scope M_New_Scope M Statement N{
                                                                                                                    scopeHandler.endScope();
                                                                                                                    CodeBuffer::instance().bpatch(static_cast<BoolExp*>($3)->trueList,
                                                                                                                                                  static_cast<BoolExp*>($5)->midLabel);
                                                                                                                    CodeBuffer::instance().bpatch(static_cast<BoolExp*>($3)->falseList,
                                                                                                                                                  static_cast<BoolExp*>($12)->midLabel);

                                                                                                                    $$ = new Statement();
                                                                                                                    static_cast<Statement*>($$)->isControl = true;
                                                                                                                    static_cast<Statement*>($$)->nextList = CodeBuffer::merge(static_cast<Statement*>($7)->nextList, 
                                                                                                                                                            CodeBuffer::merge(static_cast<Statement*>($9)->nextList,
                                                                                                                                                            CodeBuffer::merge(static_cast<Statement*>($13)->nextList,
                                                                                                                                                                              static_cast<Statement*>($14)->nextList)));                              
                                                                                                                    
                                                                                                                    static_cast<Exp*>($3)->selfBPatch();
                                                                                                                    delete $3;
                                                                                                                    delete $5;
                                                                                                                    delete $7;
                                                                                                                    delete $9;
                                                                                                                    delete $12;
                                                                                                                    delete $13;
                                                                                                                    delete $14;
                                                                                                                }
                | WHILE M_While LPAREN M_Bool_Exp RPAREN M_New_Scope M Statement N{
                                                                                        CodeBuffer::instance().bpatch(static_cast<BoolExp*>($4)->trueList,
                                                                                                                      static_cast<BoolExp*>($7)->midLabel);
                                                                                        CodeBuffer::instance().bpatch(static_cast<Statement*>($8)->nextList,
                                                                                                                      static_cast<BoolExp*>($4)->label);
                                                                                        CodeBuffer::instance().bpatch(static_cast<Statement*>($9)->nextList,
                                                                                                                      static_cast<BoolExp*>($4)->label);                              
                                                                                        $$ = new Statement();
                                                                                        static_cast<Statement*>($$)->isControl = true;

                                                                                        static_cast<Statement*>($$)->nextList = CodeBuffer::merge(static_cast<BoolExp*>($4)->falseList,
                                                                                                                                                  breakList.back());

                                                                                        CodeBuffer::instance().bpatch(continueList.back(),
                                                                                                                      static_cast<BoolExp*>($4)->label);
                                                                                        while_count--;
                                                                                        breakList.pop_back();
                                                                                        continueList.pop_back();
                                                                                        scopeHandler.endScope();

                                                                                        static_cast<Exp*>($4)->selfBPatch();
                                                                                        delete $4;
                                                                                        delete $7;
                                                                                        delete $8;
                                                                                        delete $9;
                                                                                    }
                | BREAK SC  {
                                if(!while_count){
                                    output::errorUnexpectedBreak(yylineno);
                                    exit(0);
                                }
                                $$ = new Statement();
                                std::string str = "br label @";
                                int bp = CodeBuffer::instance().emit(str);
                                breakList.back().emplace_back(bp, FIRST);
                            }
                | CONTINUE SC   {
                                    if (!while_count){
                                        output::errorUnexpectedContinue(yylineno);
                                        exit(0);
                                    }
                                    $$ = new Statement();
                                    std::string str = "br label @";
                                    int bp = CodeBuffer::instance().emit(str);
                                    continueList.back().emplace_back(bp, FIRST);

                                }
;

Call:       ID LPAREN ExpList RPAREN{
                                        TableEntry* entry =scopeHandler.findSymbol(static_cast<Id*>($1)->name);
                                        if (!entry){
                                            output::errorUndefFunc(yylineno,  static_cast<Id*>($1)->name);
                                            exit(0);
                                        }
                                        if(entry->type.find("->") == -1){
                                            output::errorUndefFunc(yylineno, static_cast<Id*>($1)->name);
                                            exit(0);
                                        }
                                        std::vector<std::string> params = getFuncParams(entry);
                                        if(static_cast<ExpList*>($3)->expressions.size() != params.size()){
                                            output::errorPrototypeMismatch(yylineno, entry->name, params);
                                            exit(0);
                                        } 
                                        int i = 0;
                                        for(auto& exp : static_cast<ExpList*>($3)->expressions){
                                            if((exp->type != params[i]) and ((exp->type != "BYTE") 
                                                or (params[i] != "INT"))){
                                                output::errorPrototypeMismatch(yylineno, entry->name, params);
                                                exit(0);
                                            }
                                            ++i;
                                        }


                                        std::vector<std::string> varlist;
                                        for (auto& exp: static_cast<ExpList*>($3)->expressions){
                                            if(exp->type == "BOOL")
                                                varlist.push_back("i1 " + std::dynamic_pointer_cast<BoolExp>(exp)->evaluate());
                                            else if(exp->type == "STRING"){
                                                varlist.push_back(std::dynamic_pointer_cast<StringExp>(exp)->var);
                                            }    
                                            else
                                                varlist.push_back("i32 " + exp->var);
                                        }
                                        std::string new_var = "";
                                        std::string str = "";
                                        if(getFuncReturn(entry) != "VOID"){
                                            new_var = CodeBuffer::instance().freshVar();
                                            str = new_var + " = call @" + static_cast<Id*>($1)->name + "(" ;
                                        }
                                        else
                                            str = "call @" + static_cast<Id*>($1)->name + "(" ;
                                        for (auto& var: varlist){
                                            str += var + ", ";
                                        }
                                        str.pop_back();
                                        str.pop_back();
                                        str += ")";

                                        $$ = new CallExp(getFuncReturn(entry), new_var);
                                        static_cast<Exp*>($$)->anounce();

                                        CodeBuffer::instance().emit(str);
                                        delete $1;
                                        delete $3;
                                    }
            | ID LPAREN RPAREN  {
                                    TableEntry* entry =scopeHandler.findSymbol(static_cast<Id*>($1)->name);
                                    if (!entry){
                                            output::errorUndefFunc(yylineno,  static_cast<Id*>($1)->name);
                                            exit(0);
                                    }
                                    if(entry->type.find("->") == -1){
                                        output::errorUndefFunc(yylineno,  static_cast<Id*>($1)->name);
                                        exit(0);
                                    }
                                    vector<string> params = getFuncParams(entry);
                                    if (params.size() != 0){
                                        output::errorPrototypeMismatch(yylineno, entry->name, params);
                                        exit(0);
                                    }


                                    std::string new_var = "";
                                    std::string str = "";
                                    if(getFuncReturn(entry) != "VOID"){
                                        new_var = CodeBuffer::instance().freshVar();
                                        str = new_var + " = call @" + static_cast<Id*>($1)->name + "()" ;
                                    }
                                    else
                                        str = "call @" + static_cast<Id*>($1)->name + "()" ;

                                    $$ = new CallExp(getFuncReturn(entry), new_var);  
                                    static_cast<Exp*>($$)->anounce();

                                    CodeBuffer::instance().emit(str);
                                    
 

                                    delete $1;
                                }
;   

ExpList:    Exp {
                    ExpList* expList = new ExpList(std::vector<std::shared_ptr<Exp>>());
                    if (static_cast<Exp*>($1)->type == "BOOL"){
                        BoolExp* exp = new BoolExp(static_cast<BoolExp*>($1)->var);
                        exp->trueList = static_cast<BoolExp*>($1)->trueList;
                        exp->falseList = static_cast<BoolExp*>($1)->falseList;
                        expList->expressions.push_back(std::shared_ptr<Exp> (exp));
                    }
                    else if (static_cast<Exp*>($1)->type == "STRING")
                        expList->expressions.push_back(std::shared_ptr<Exp> (new StringExp(static_cast<StringExp*>($1)->value, static_cast<Exp*>($1)->var)));
                    else
                        expList->expressions.push_back(std::shared_ptr<Exp> (new Exp(static_cast<Exp*>($1)->type,static_cast<Exp*>($1)->var)));
                    $$ = expList;
                    
                    static_cast<Exp*>($1)->selfBPatch();
                    delete $1; 
                }
            | Exp COMMA ExpList {
                                    ExpList* expList = new ExpList(static_cast<ExpList*>($3)->expressions); //potential bug
                                    if (static_cast<Exp*>($1)->type == "BOOL"){
                                        BoolExp* exp = new BoolExp(static_cast<BoolExp*>($1)->var);
                                        exp->trueList = static_cast<BoolExp*>($1)->trueList;
                                        exp->falseList = static_cast<BoolExp*>($1)->falseList;
                                        expList->expressions.insert(expList->expressions.begin(), std::shared_ptr<Exp> (exp));
                                    }
                                    else if (static_cast<Exp*>($1)->type == "STRING")
                                        expList->expressions.insert(expList->expressions.begin(), std::shared_ptr<Exp> (new StringExp(static_cast<StringExp*>($1)->value, static_cast<Exp*>($1)->var)));
                                    else
                                        expList->expressions.insert(expList->expressions.begin(), std::shared_ptr<Exp> (new Exp(static_cast<Exp*>($1)->type,static_cast<Exp*>($1)->var)));  
                                    $$ = expList;

                                    static_cast<Exp*>($1)->selfBPatch();
                                    delete $1;
                                    delete $3; 
                                }
;

Type:     INT   {
                    $$ = new Type("INT");
                }
        | BYTE  {
                    $$ = new Type("BYTE");
                }
        | BOOL  {
                    $$ = new Type("BOOL");
                }
;

M_Bool_Exp: Exp {
                    if(static_cast<Exp*>($1)->type != "BOOL"){
                        output::errorMismatch(yylineno);
                        exit(0);
                    }
                    $$ = new BoolExp(static_cast<Exp*>($1)->var);
                    static_cast<BoolExp*>($$)->trueList = static_cast<BoolExp*>($1)->trueList;
                    static_cast<BoolExp*>($$)->falseList = static_cast<BoolExp*>($1)->falseList;
                    static_cast<Exp*>($$)->forward_anouncement(static_cast<Exp*>($1));
                    delete $1;
                }
;

Exp:    LPAREN Exp RPAREN   { 
                                if (static_cast<Exp*>($2)->type == "BOOL"){
                                    BoolExp* exp = new BoolExp(static_cast<BoolExp*>($2)->var);
                                    exp->trueList = static_cast<BoolExp*>($2)->trueList;
                                    exp->falseList = static_cast<BoolExp*>($2)->falseList;
                                }
                                else if(static_cast<Exp*>($2)->type == "STRING")
                                    $$ = new StringExp(static_cast<StringExp*>($2)->value, static_cast<Exp*>($2)->var);
                                else
                                    $$ = new Exp(static_cast<Exp*>($2)->type, static_cast<Exp*>($2)->var);

                                static_cast<Exp*>($$)->forward_anouncement(static_cast<Exp*>($2));
                                delete $2;
                            }
                    
        |Exp IF LPAREN M_Bool_Exp RPAREN ELSE Exp N M %prec TERNARY
                                            {
                                                if(static_cast<Exp*>($1)->type == static_cast<Exp*>($7)->type or (static_cast<Exp*>($1)->type == "BYTE" and static_cast<Exp*>($7)->type == "INT")){
                                                    if(static_cast<Exp*>($1)->type == "BOOL"){
                                                        $$ = new BoolExp();
                                                        static_cast<BoolExp*>($$)->trueList = CodeBuffer::merge(static_cast<BoolExp*>($1)->trueList, static_cast<BoolExp*>($7)->trueList);
                                                        static_cast<BoolExp*>($$)->falseList = CodeBuffer::merge(static_cast<BoolExp*>($1)->falseList, static_cast<BoolExp*>($7)->falseList);
                                                    }
                                                    else if(static_cast<Exp*>($1)->type == "STRING"){
                                                        $$ = new StringExp();
                                                    }
                                                    else
                                                        $$ = new Exp(static_cast<Exp*>($7)->type);
                                                }
                                                else if(static_cast<Exp*>($1)->type == "INT" and static_cast<Exp*>($7)->type == "BYTE"){
                                                    $$ = new Exp(static_cast<Exp*>($1)->type);
                                                }
                                                else{
                                                    output::errorMismatch(yylineno);
                                                    exit(0);
                                                }
                                                static_cast<Exp*>($$)->anounce();
                                                
                                                CodeBuffer::instance().bpatch(static_cast<Exp*>($1)->bp, static_cast<BoolExp*>($4)->label);

                                                
                                                CodeBuffer::instance().bpatch(static_cast<Exp*>($4)->bp, static_cast<BoolExp*>($9)->midLabel);
                                                CodeBuffer::instance().bpatch(static_cast<BoolExp*>($4)->trueList, static_cast<BoolExp*>($1)->label);
                                                CodeBuffer::instance().bpatch(static_cast<BoolExp*>($4)->falseList, static_cast<BoolExp*>($7)->label);

                                                static_cast<BoolExp*>($7)->selfBPatch();
                                                CodeBuffer::instance().bpatch(static_cast<Statement*>($8)->nextList, static_cast<BoolExp*>($9)->midLabel);

                                                
                                                if(static_cast<Exp*>($1)->type != "BOOL"){
                                                    std::string var = CodeBuffer::instance().freshVar();
                                                    std::string str = var + " = phi i32 [ " + static_cast<Exp*>($1)->var + ", %" + static_cast<Exp*>($1)->label + " ], [ " +
                                                           static_cast<Exp*>($7)->var + ", %" + static_cast<Exp*>($7)->label + " ]";
                                                    CodeBuffer::instance().emit(str);
                                                    static_cast<Exp*>($$)->var = var;
                                                }
                                                
                                                delete $1;
                                                delete $4;
                                                delete $7;
                                                delete $8;
                                                delete $9;
                                            }

        | Exp PLUS_MINUS Exp{
                                if (static_cast<Exp*>($1)->type == "INT" ){
                                    if(static_cast<Exp*>($3)->type == "INT" or static_cast<Exp*>($3)->type == "BYTE")
                                    {    
                                        $$ = new Exp("INT", CodeBuffer::instance().freshVar());
                                        static_cast<Exp*>($$)->anounce();
                                        static_cast<Exp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<PlusMinus*>($2)->op, static_cast<Exp*>($3));
                                    }
                                    else{
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    }
                                }
                                else if (static_cast<Exp*>($1)->type == "BYTE"){
                                    if(static_cast<Exp*>($3)->type == "INT")
                                    {    
                                        $$ = new Exp("INT", CodeBuffer::instance().freshVar());
                                        static_cast<Exp*>($$)->anounce();
                                        static_cast<Exp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<PlusMinus*>($2)->op, static_cast<Exp*>($3));
                                    }
                                    else if(static_cast<Exp*>($3)->type == "BYTE")
                                    {    
                                        $$ = new Exp("BYTE", CodeBuffer::instance().freshVar());
                                        static_cast<Exp*>($$)->anounce();
                                        static_cast<Exp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<PlusMinus*>($2)->op, static_cast<Exp*>($3));
                                    }                                    
                                    else{
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    }
                                }
                                else{
                                    output::errorMismatch(yylineno);
                                    exit(0);
                                }

                                static_cast<Exp*>($1)->selfBPatch();
                                static_cast<Exp*>($3)->selfBPatch();
                                delete $1;
                                delete $2;
                                delete $3;
                            }
        | Exp MUL_DIV Exp   {
                                if (static_cast<Exp*>($1)->type == "INT" ){
                                    if(static_cast<Exp*>($3)->type == "INT" or static_cast<Exp*>($3)->type == "BYTE")
                                    {    
                                        $$ = new Exp("INT", CodeBuffer::instance().freshVar());
                                        static_cast<Exp*>($$)->anounce();
                                        static_cast<Exp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<MulDiv*>($2)->op, static_cast<Exp*>($3));
                                    }
                                    else{
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    };
                                }
                                else if (static_cast<Exp*>($1)->type == "BYTE"){
                                    if(static_cast<Exp*>($3)->type == "INT")
                                    {    
                                        $$ = new Exp("INT", CodeBuffer::instance().freshVar());
                                        static_cast<Exp*>($$)->anounce();
                                        static_cast<Exp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<MulDiv*>($2)->op, static_cast<Exp*>($3));
                                    }
                                    else if(static_cast<Exp*>($3)->type == "BYTE")
                                    {    
                                        $$ = new Exp("BYTE", CodeBuffer::instance().freshVar());
                                        static_cast<Exp*>($$)->anounce();
                                        static_cast<Exp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<MulDiv*>($2)->op, static_cast<Exp*>($3));
                                    }
                                    else{
                                        output::errorMismatch(yylineno); 
                                        exit(0);
                                    }
                                }
                                else{
                                    output::errorMismatch(yylineno); 
                                    exit(0);
                                }
                                
                                static_cast<Exp*>($1)->selfBPatch();
                                static_cast<Exp*>($3)->selfBPatch();
                                delete $1;
                                delete $2;
                                delete $3;                            
                            }
        | ID{  
                TableEntry* entry =scopeHandler.findSymbol(static_cast<Id*>($1)->name);
                if(entry){
                    if(entry->type.find("->") == -1){
                        std::string var;
                        Exp exp("DUMMY");
                        exp.anounce();
                        if (entry->offset >= 0)
                            var = entry->emit_load(base, baseList);
                        else
                            var = entry->var;

                        if(entry->type == "BOOL"){
                            $$ = new BoolExp(var);
                            static_cast<BoolExp*>($$)->emit();
                            static_cast<Exp*>($$)->forward_anouncement(&exp);
                        }
                        else{
                            $$ = new Exp(entry->type, var);
                            static_cast<Exp*>($$)->forward_anouncement(&exp);
                        }
                    }
                    else{
                        output::errorUndef(yylineno, static_cast<Id*>($1)->name);
                        exit(0);                        
                    }
                }
                else{
                    output::errorUndef(yylineno, static_cast<Id*>($1)->name);
                    exit(0);
                }

                delete $1;
            }
        | Call {    
                    
                    if(static_cast<CallExp*>($1)->type == "BOOL"){
                        $$ = new BoolExp(static_cast<CallExp*>($1)->var);
                        static_cast<BoolExp*>($$)->emit();
                    }

                    else
                        $$ = new Exp(static_cast<CallExp*>($1)->type, static_cast<CallExp*>($1)->var);
                    

                    static_cast<Exp*>($$)->forward_anouncement(static_cast<Exp*>($1));
                    delete $1;
               }
        | NUM   { 
                    $$ = new Exp("INT", std::to_string((static_cast<Num*>($1))->value));
                    static_cast<Exp*>($$)->anounce();
                    delete $1;
                }
        | NUM B {
                    if (static_cast<Num*>($1)->value <= 255) 
                        $$ = new Exp("BYTE", std::to_string((static_cast<Num*>($1))->value));
                    else{
                        output::errorByteTooLarge(yylineno,std::to_string(static_cast<Num*>($1)->value));
                        exit(0);
                    }

                    static_cast<Exp*>($$)->anounce();
                    delete $1;
                }
        | STRING{ 
                    std::string var = CodeBuffer::instance().freshVar();
                    var = "@." + var.substr(1);
                    $$ = new StringExp(static_cast<String*>($1)->value, var); 
                    static_cast<StringExp*>($$)->emitGlobalString();

                    static_cast<Exp*>($$)->anounce();
                    delete $1;
                }   

        | TRUE  { 
                    $$ = new BoolExp("true");
                    static_cast<Exp*>($$)->anounce();
                    static_cast<BoolExp*>($$)->emit(); 
                }
        | FALSE { 
                    $$ = new BoolExp("false");
                    static_cast<Exp*>($$)->anounce();
                    static_cast<BoolExp*>($$)->emit();  
                }
        | NOT Exp   { 
                        if(static_cast<Exp*>($2)->type == "BOOL")
                            {    
                                $$ = new BoolExp(static_cast<Exp*>($2)->var);
                                static_cast<BoolExp*>($$)->notOp(static_cast<Exp*>($2));
                            }
                            
                        else{
                            output::errorMismatch(yylineno);
                            exit(0);
                        }
                        
                        static_cast<Exp*>($$)->forward_anouncement(static_cast<Exp*>($2));
                        delete $2; 
                    }
        | Exp AND Exp   {
                            if(static_cast<Exp*>($1)->type == "BOOL" and static_cast<Exp*>($3)->type == "BOOL")
                            {    
                                $$ = new BoolExp();
                                static_cast<BoolExp*>($$)->emitOp(static_cast<Exp*>($1), "and", static_cast<Exp*>($3));
                            }
                            else{
                                output::errorMismatch(yylineno);
                                exit(0);
                            }
                            static_cast<Exp*>($$)->forward_anouncement(static_cast<Exp*>($1));

                            static_cast<Exp*>($3)->selfBPatch();
                            delete $1;
                            delete $3;     
                        }
        | Exp OR Exp{ 
                        if(static_cast<Exp*>($1)->type == "BOOL" and static_cast<Exp*>($3)->type == "BOOL")
                            {    
                                $$ = new BoolExp();
                                static_cast<BoolExp*>($$)->emitOp(static_cast<Exp*>($1), "or", static_cast<Exp*>($3));
                            }
                        else{
                            output::errorMismatch(yylineno);
                            exit(0);
                        }
                        static_cast<Exp*>($$)->forward_anouncement(static_cast<Exp*>($1));

                        static_cast<Exp*>($3)->selfBPatch();
                        delete $1;
                        delete $3;
                    }      
        | Exp RELOP Exp { 
                            if((static_cast<Exp*>($1)->type == "INT" or static_cast<Exp*>($1)->type == "BYTE") 
                                and (static_cast<Exp*>($3)->type == "INT" or static_cast<Exp*>($3)->type == "BYTE"))
                                    {    
                                        $$ = new BoolExp(CodeBuffer::instance().freshVar());
                                        static_cast<Exp*>($$)->anounce();
                                        static_cast<BoolExp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<Relop*>($2)->op, static_cast<Exp*>($3));
                                    }
                            else{
                                output::errorMismatch(yylineno);
                                exit(0);
                            }

                            static_cast<Exp*>($1)->selfBPatch();
                            static_cast<Exp*>($3)->selfBPatch();
                            delete $1;
                            delete $2;                                
                            delete $3;
                        }
        | Exp EQUAL Exp { 
                            if((static_cast<Exp*>($1)->type == "INT" or static_cast<Exp*>($1)->type == "BYTE") 
                                and (static_cast<Exp*>($3)->type == "INT" or static_cast<Exp*>($3)->type == "BYTE"))
                                    {    
                                        $$ = new BoolExp(CodeBuffer::instance().freshVar());
                                        static_cast<Exp*>($$)->anounce();
                                        static_cast<BoolExp*>($$)->emitOp(static_cast<Exp*>($1), static_cast<Equal*>($2)->op, static_cast<Exp*>($3));
                                    }
                            else{
                                output::errorMismatch(yylineno);
                                exit(0);
                            }

                            static_cast<Exp*>($1)->selfBPatch();
                            static_cast<Exp*>($3)->selfBPatch();
                            delete $1;
                            delete $2;
                            delete $3;
                        }
        | LPAREN Type RPAREN Exp{  
                                    if (static_cast<Type*>($2)->type == "INT" and (static_cast<Exp*>($4)->type == "INT" or static_cast<Exp*>($4)->type == "BYTE")){
                                        $$ = new Exp("INT",static_cast<Exp*>($4)->var);
                                        static_cast<Exp*>($$)->forward_anouncement(static_cast<Exp*>($4));
                                    }
                                    else if (static_cast<Type*>($2)->type == "BYTE" and (static_cast<Exp*>($4)->type == "INT" or static_cast<Exp*>($4)->type == "BYTE")){
                                        $$ = new Exp("BYTE", static_cast<Exp*>($4)->var);
                                        if(static_cast<Exp*>($4)->type != "BYTE"){
                                            static_cast<Exp*>($$)->anounce();
                                            static_cast<Exp*>($$)->emitOp(nullptr, "", nullptr);
                                            static_cast<Exp*>($4)->selfBPatch();
                                        }
                                        else{
                                            static_cast<Exp*>($$)->forward_anouncement(static_cast<Exp*>($4));
                                        }
                                    }
                                    else{
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    }

                                    delete $2;
                                    delete $4;  
                                }
;

%%

void yyerror(const char*) 
{ 
    errorSyn(yylineno);
    exit(0); 
}
void prologue(){
    CodeBuffer::instance().emitGlobal("declare i32 @printf(i8*, ...)");
    CodeBuffer::instance().emitGlobal("declare void @exit(i32)");
    CodeBuffer::instance().emitGlobal("@.int_specifier = constant [4 x i8] c\"%d\\0A\\00\"");
    CodeBuffer::instance().emitGlobal("@.str_specifier = constant [4 x i8] c\"%s\\0A\\00\"");
    CodeBuffer::instance().emitGlobal("@.div_error = internal constant [23 x i8] c\"Error division by zero\\00\"");
    CodeBuffer::instance().emit("define void @printi(i32) {");
    CodeBuffer::instance().emit("\t%spec_ptr = getelementptr [4 x i8], [4 x i8]* @.int_specifier, i32 0, i32 0");
    CodeBuffer::instance().emit("\tcall i32 (i8*, ...) @printf(i8* %spec_ptr, i32 %0)");
    CodeBuffer::instance().emit("\tret void");
    CodeBuffer::instance().emit("}");
    CodeBuffer::instance().emit("define void @print(i8*) {");
    CodeBuffer::instance().emit("\t%spec_ptr = getelementptr [4 x i8], [4 x i8]* @.str_specifier, i32 0, i32 0");
    CodeBuffer::instance().emit("\tcall i32 (i8*, ...) @printf(i8* %spec_ptr, i8* %0)");
    CodeBuffer::instance().emit("\tret void");
    CodeBuffer::instance().emit("}");
}

int main() {
    //yydebug = 1;
    prologue();
    return yyparse();
}
